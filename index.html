<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Campus Utility Dashboard</title>
    <!-- Matter.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        :root {
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            --text-color: #EEE;

            /* Utility Colors */
            --elec-color: #f1c40f;
            --water-color: #3498db;
            --hvac-color: #2ecc71;
            --occ-color: #9b59b6;
            --wifi-color: #e74c3c;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            /* Prevent text selection while dragging */
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: radial-gradient(circle at 50% 50%, #1a1a2e 0%, #16213e 50%, #0f0f1a 100%);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: var(--text-color);
            height: 100vh;
            width: 100vw;
        }

        /* Container for the physics connected elements */
        #scene-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* Let clicks pass through to canvas if needed, but we handle via Mapping */
        }

        /* The transparent canvas for Matter.js mouse interaction */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            /* On top to catch mouse events */
        }

        /* Common Card Styles */
        .utility-card {
            position: absolute;
            top: 0;
            left: 0;
            /* Width/Height will be instantly overriden by JS but good for initial flush */
            width: 200px;
            height: 120px;

            background: var(--glass-bg);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            box-shadow: var(--glass-shadow);

            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;

            /* Transform origin center for accurate rotation mapping */
            transform-origin: 50% 50%;
            will-change: transform;

            /* Visual flair */
            transition: box-shadow 0.2s;
        }

        /* Type specific accents */
        .card-elec {
            border-left: 4px solid var(--elec-color);
        }

        .card-water {
            border-left: 4px solid var(--water-color);
        }

        .card-hvac {
            border-left: 4px solid var(--hvac-color);
        }

        .card-occ {
            border-left: 4px solid var(--occ-color);
        }

        .card-wifi {
            border-left: 4px solid var(--wifi-color);
        }

        .icon {
            font-size: 2rem;
            margin-bottom: 8px;
            filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.3));
        }

        .data-value {
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: 0.5px;
        }

        .label {
            font-size: 0.8rem;
            opacity: 0.7;
            text-transform: uppercase;
            margin-top: 4px;
        }

        /* Controls */
        #ui-layer {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
        }

        .btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 20px;
            border-radius: 30px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(0);
        }
    </style>
</head>

<body>

    <!-- Physics interaction layer (Canvas) generated by Matter.js will go here implicitly or explicitly -->

    <div id="scene-container">
        <!-- These elements will be moved by JS to match Physics Bodies -->
        <!-- Populated via JS for cleaner syncing setup -->
    </div>

    <div id="ui-layer">
        <button id="toggle-gravity" class="btn">Toggle Gravity</button>
    </div>

    <script>
        // --- 1. Setup & Configuration ---
        const Engine = Matter.Engine,
            Render = Matter.Render,
            Runner = Matter.Runner,
            Bodies = Matter.Bodies,
            Composite = Matter.Composite,
            Events = Matter.Events,
            Mouse = Matter.Mouse,
            MouseConstraint = Matter.MouseConstraint,
            Query = Matter.Query;

        // Constants
        const CARD_WIDTH = 220;
        const CARD_HEIGHT = 140;
        const WALL_THICKNESS = 100;

        // Data Models
        const utilities = [
            { type: 'elec', icon: 'âš¡', label: 'Electricity', value: '450 kWh' },
            { type: 'water', icon: 'ðŸ’§', label: 'Water', value: '1,200 L' },
            { type: 'hvac', icon: 'â„ï¸', label: 'HVAC / Air', value: '22Â°C' },
            { type: 'occ', icon: 'ðŸ‘¥', label: 'Occupancy', value: '85% Full' },
            { type: 'wifi', icon: 'ðŸ“¶', label: 'Wi-Fi Load', value: '300 Mbps' }
        ];

        // --- 2. Initialization ---
        const engine = Engine.create();
        const world = engine.world;

        // Create Render (WebGl/Canvas) - acting as the "interaction layer"
        // We'll keep the wireframes transparent so we see our HTML cards, 
        // but the canvas will capture mouse events.
        const render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                background: 'transparent',
                wireframes: false, // Set to true for debugging physics
                showAngleIndicator: false
            }
        });

        // Hide the actual bodies in the render (make them transparent)
        // because we are rendering them via HTML
        // CSS in JS approach for the render style
        // Actually, easiest is setting opacity 0 in their render options.

        // --- 3. Create Bodies & DOM Elements ---
        const sceneContainer = document.getElementById('scene-container');
        const cardBodies = [];

        utilities.forEach((util, index) => {
            // Random start position within view
            const x = Math.random() * (window.innerWidth - CARD_WIDTH) + CARD_WIDTH / 2;
            const y = Math.random() * (window.innerHeight - CARD_HEIGHT - 200) - 200; // Start slightly above or top area

            // Create Physics Body
            const body = Bodies.rectangle(x, y, CARD_WIDTH, CARD_HEIGHT, {
                chamfer: { radius: 16 }, // Rounded corners matching CSS
                restitution: 0.6, // Bounciness
                density: 0.001,
                render: {
                    fillStyle: 'transparent',
                    strokeStyle: 'transparent',
                    opacity: 0 // Invisible in canvas, visible in DOM
                },
                label: util.label // For identification
            });

            // Create DOM Element
            const cardEl = document.createElement('div');
            cardEl.className = `utility-card card-${util.type}`;
            cardEl.style.width = `${CARD_WIDTH}px`;
            cardEl.style.height = `${CARD_HEIGHT}px`;
            cardEl.innerHTML = `
                <div class="icon">${util.icon}</div>
                <div class="data-value">${util.value}</div>
                <div class="label">${util.label}</div>
            `;
            sceneContainer.appendChild(cardEl);

            // Link them
            body.domElement = cardEl; // Custom prop
            body.utilData = util;     // Store data for click events

            cardBodies.push(body);
        });

        Composite.add(world, cardBodies);

        // --- 4. Walls / Boundaries ---
        let ground, leftWall, rightWall, ceiling;

        function createBoundaries() {
            // Remove old if any
            if (ground) Composite.remove(world, [ground, leftWall, rightWall, ceiling]);

            const width = window.innerWidth;
            const height = window.innerHeight;

            // Static bodies
            const options = {
                isStatic: true,
                render: { visible: false } // Invisible walls
            };

            ground = Bodies.rectangle(width / 2, height + WALL_THICKNESS / 2, width + 200, WALL_THICKNESS, options);
            leftWall = Bodies.rectangle(0 - WALL_THICKNESS / 2, height / 2, WALL_THICKNESS, height * 2, options);
            rightWall = Bodies.rectangle(width + WALL_THICKNESS / 2, height / 2, WALL_THICKNESS, height * 2, options);

            // Ceiling (optional, prevents flying off top if gravity reversed)
            ceiling = Bodies.rectangle(width / 2, -WALL_THICKNESS * 2, width + 200, WALL_THICKNESS, options);

            Composite.add(world, [ground, leftWall, rightWall, ceiling]);
        }

        createBoundaries();

        // --- 5. Inputs & Interaction ---

        // Mouse Control
        const mouse = Mouse.create(render.canvas);
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                stiffness: 0.2,
                render: {
                    visible: false
                }
            }
        });
        Composite.add(world, mouseConstraint);

        // Keep the mouse in sync with rendering
        render.mouse = mouse;

        // Gravity Toggle
        let gravityEnabled = true;
        document.getElementById('toggle-gravity').addEventListener('click', () => {
            gravityEnabled = !gravityEnabled;
            if (gravityEnabled) {
                engine.gravity.y = 1;
                document.getElementById('toggle-gravity').textContent = "Toggle Zero-G";
            } else {
                engine.gravity.y = 0;
                document.getElementById('toggle-gravity').textContent = "Enable Gravity";

                // Give them a little push so they float apart if stacked
                cardBodies.forEach(body => {
                    Matter.Body.applyForce(body, body.position, {
                        x: (Math.random() - 0.5) * 0.05,
                        y: (Math.random() - 0.5) * 0.05
                    });
                });
            }
        });

        // Double Click Detection
        render.canvas.addEventListener('dblclick', (event) => {
            // Matter.js needs coordinates relative to the canvas/world
            // Since our canvas is full screen, clientX/Y work fine usually,
            // but let's be safe and use mouse.position from the last update or event
            const mousePosition = mouse.position;

            // Query the bodies under the mouse
            const bodiesUnderCursor = Query.point(cardBodies, mousePosition);

            if (bodiesUnderCursor.length > 0) {
                // Get the top one
                const body = bodiesUnderCursor[0];
                const data = body.utilData;

                // Show Details
                alert(`--- detailed Analytics ---\n\nUtility: ${data.label}\nCurrent Load: ${data.value}\nStatus: Optimal\nTrend: Stable`);
            }
        });

        // --- 6. Sync Loop ---
        Events.on(engine, 'afterUpdate', () => {
            cardBodies.forEach(body => {
                const domEl = body.domElement;
                if (!domEl) return;

                const { x, y } = body.position;
                const angle = body.angle;

                // Sync position and rotation
                // - Translate needs to center the element. 
                //   Our CSS width/height is fixed, and position is top:0, left:0.
                //   Matter.js x/y is the center of mass.
                //   So we translate to (x - width/2, y - height/2).

                const transX = x - CARD_WIDTH / 2;
                const transY = y - CARD_HEIGHT / 2;

                domEl.style.transform = `translate(${transX}px, ${transY}px) rotate(${angle}rad)`;
            });
        });

        // --- 7. Run Everything ---
        // Run the renderer
        Render.run(render);

        // Create runner
        const runner = Runner.create();
        Runner.run(runner, engine);

        // --- 8. Resize Handling ---
        window.addEventListener('resize', () => {
            render.canvas.width = window.innerWidth;
            render.canvas.height = window.innerHeight;

            // Recreate walls
            createBoundaries();
        });

    </script>
</body>

</html>